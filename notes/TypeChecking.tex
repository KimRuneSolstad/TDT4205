\section{Type Checking}
To do type checking, a compiler needs to assign a type expression to each component of the source program. It must then determine that these type expressions conform to a collection of logical rules that is called the type system for the source language. \\
\emph{type synthesis}: builds up the type of an expression from the types of its subexpressions. \\
\emph{type inference}: determines the type of language construct from the way it is used. \\

\subsection{Type conversions}
\emph{widening} conversions: conversions intended to preserve information. \\
\emph{narrowing} conversions: conversions where you might lose information. \\

\emph{coercions}: implicit type conversion, conversion from one type to another done automatically by the compielr. \\
\emph{casts}: explicit type conversion, conversion from one type to another done by writing this in the conde. \\

\subsection{Overloading of Functions and Operators}
An overloaded symbol has different meanings depending on its context. Overloading isresolved when a unique meaning is determined for each occurence of a name.
\subsection{Type inference and Polymorphic Functions}
Type inference is useful for a l√∏anguage like ML, wich is strongly typed, but does not require names to be declared before useage. Type inference ensures that names are used consistently.
